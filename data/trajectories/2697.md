**Question:** For Belles_cookbook_store in January, if we were to move the fraudulent transactions towards a different Authorization Characteristics Indicator (ACI) by incentivizing users to use a different interaction, what would be the preferred choice considering the lowest possible fees?

**Guidelines:** Answer must be just the selected ACI to incentive and the associated cost rounded to 2 decimals in this format: {aci}:{fee}. If a question does not have a relevant or applicable answer for the task, please respond with 'Not Applicable'.

**Code:**
```py
import json
import csv
import re

def parse_percentage_range(percentage_range):
    """Parse a percentage range string like '<8.3%' or '7.2%-7.7%' into a tuple."""
    if percentage_range is None:
        return None
    if percentage_range.startswith('<'):
        return (0, float(percentage_range[1:-1]))
    elif percentage_range.startswith('>'):
        return (float(percentage_range[1:-1]), float('inf'))
    elif '-' in percentage_range:
        lower, upper = map(float, re.findall(r'\d+\.\d+', percentage_range))
        return (lower, upper)
    return None

def parse_volume_range(volume_range):
    """Parse a volume range string like '<100k' or '1m-5m' into a tuple."""
    if volume_range is None:
        return None
    multiplier = {'k': 1_000, 'm': 1_000_000}
    if volume_range.startswith('<'):
        value = float(re.findall(r'\d+', volume_range)[0]) * multiplier[volume_range[-1]]
        return (0, value)
    elif volume_range.startswith('>'):
        value = float(re.findall(r'\d+', volume_range)[0]) * multiplier[volume_range[-1]]
        return (value, float('inf'))
    elif '-' in volume_range:
        lower, upper = re.findall(r'\d+[km]', volume_range)
        lower_value = float(re.findall(r'\d+', lower)[0]) * multiplier[lower[-1]]
        upper_value = float(re.findall(r'\d+', upper)[0]) * multiplier[upper[-1]]
        return (lower_value, upper_value)
    return None

def parse_capture_delay(fee_capture_delay):
    """Parse the capture_delay value from fees.json to handle fuzzy match cases."""
    if fee_capture_delay is None:
        return range(0, 100)

    if isinstance(fee_capture_delay, str):
        if fee_capture_delay.startswith("<"):
            upper_limit = int(fee_capture_delay[1:])
            return range(0, upper_limit)
        elif fee_capture_delay.startswith(">"):
            lower_limit = int(fee_capture_delay[1:]) + 1
            return range(lower_limit, 100)
        elif "-" in fee_capture_delay:
            lower_limit, upper_limit = map(int, fee_capture_delay.split("-"))
            return range(lower_limit, upper_limit + 1)
    return [str(fee_capture_delay)]

def is_within_range(value, range_tuple):
    """Check if a value is within a given range tuple."""
    if range_tuple is None:
        return True
    return range_tuple[0] <= float(value) <= range_tuple[1]

# Load fees data
with open('./test_case/dabstep_data/fees.json', 'r') as f:
    fees_data = json.load(f)

# Load payments data
with open('./test_case/dabstep_data/payments.csv', 'r') as f:
    reader = csv.DictReader(f)
    payments_data = [row for row in reader]

# Load merchant data
with open('./test_case/dabstep_data/merchant_data.json', 'r') as f:
    merchant_data = json.load(f)

# Extract Belles_cookbook_store's information from merchant_data
merchant_info = next((m for m in merchant_data if m['merchant'] == 'Belles_cookbook_store'), None)
if not merchant_info:
    final_answer("Not Applicable")
else:
    merchant_account_type = merchant_info['account_type']
    merchant_category_code = merchant_info['merchant_category_code']
    merchant_capture_delay = str(merchant_info['capture_delay'])
    
    belles_january_payments = [
        payment for payment in payments_data
        if payment['merchant'] == 'Belles_cookbook_store' and int(payment['day_of_year']) <= 31 and int(payment['year']) == 2023
    ]

    belles_january_fraud_payments = [tx for tx in belles_january_payments if tx['has_fraudulent_dispute'] == 'TRUE']
    fraud_count = len(belles_january_fraud_payments)
    total_count = len(belles_january_payments)

    monthly_fraud_level = (fraud_count / total_count) if total_count > 0 else 0
    monthly_volume = sum(float(tx['eur_amount']) for tx in belles_january_payments)

    aci_fees = {}
    aci_candidates = set(payment['aci'].strip() for payment in payments_data if payment['aci'].strip())

    for aci in aci_candidates:
        aci_fee = 0
        for payment in belles_january_fraud_payments:
            transaction_value = float(payment['eur_amount'])
            payment_intracountry = 1.0 if payment['issuing_country'] == payment['acquirer_country'] else 0.0
            applicable_fees = []
            
            for fee in fees_data:
                fee_monthly_fraud_level_range = parse_percentage_range(fee.get('monthly_fraud_level'))
                fee_monthly_volume_range = parse_volume_range(fee.get('monthly_volume'))
                fee_capture_delay = fee.get('capture_delay')
                fee_capture_delay_range = parse_capture_delay(fee_capture_delay)
                fee_intracountry = fee.get('intracountry')
                
                if (
                    (fee['aci'] == [] or aci in fee['aci']) and
                    (fee_intracountry is None or fee_intracountry == payment_intracountry) and
                    (fee['monthly_fraud_level'] is None or is_within_range(monthly_fraud_level, fee_monthly_fraud_level_range)) and
                    (fee['monthly_volume'] is None or is_within_range(monthly_volume, fee_monthly_volume_range)) and
                    (fee['account_type'] == [] or merchant_account_type in fee['account_type']) and
                    (fee['card_scheme'] == "" or payment['card_scheme'] == fee['card_scheme']) and
                    (fee['merchant_category_code'] == [] or merchant_category_code in fee['merchant_category_code']) and
                    (fee_capture_delay_range is None or str(merchant_capture_delay) in map(str, fee_capture_delay_range))
                ):
                    calculated_fee = fee['fixed_amount'] + fee['rate'] * transaction_value / 10000
                    applicable_fees.append(calculated_fee)

            if applicable_fees:
                aci_fee += min(applicable_fees)
            else:
                aci_fee += 0

        aci_fees[aci] = aci_fee

    # Find the ACI with the lowest fee
    if aci_fees:
        preferred_aci = min(aci_fees, key=aci_fees.get)
        answer = f"{preferred_aci}:{aci_fees[preferred_aci]:.2f}"
    else:
        answer = "Not Applicable"

    final_answer(answer)
```
