**Question:** For the 10th of the year 2023, what are the Fee IDs applicable to Belles_cookbook_store?

**Guidelines:** Answer must be a list of values in comma separated list, eg: A, B, C. If the answer is an empty list, reply with an empty string. If a question does not have a relevant or applicable answer for the task, please respond with 'Not Applicable'.

**Code:**
```py
import json
import csv
import re
from datetime import datetime

# Load fees data from the JSON file
with open('./test_case/dabstep_data/fees.json', 'r') as f:
    fees_data = json.load(f)

# Load merchant data from the JSON file
with open('./test_case/dabstep_data/merchant_data.json', 'r') as f:
    merchant_data = json.load(f)

def parse_percentage_range(percentage_range):
    """Parse a percentage range string like '<8.3%' or '7.2%-7.7%' into a tuple."""
    if percentage_range is None:
        return None
    if percentage_range.startswith('<'):
        return (0, float(percentage_range[1:-1]))
    elif percentage_range.startswith('>'):
        return (float(percentage_range[1:-1]), float('inf'))
    elif '-' in percentage_range:
        lower, upper = map(float, re.findall(r'\d+\.\d+', percentage_range))
        return (lower, upper)
    return None

def parse_volume_range(volume_range):
    """Parse a volume range string like '<100k' or '1m-5m' into a tuple."""
    if volume_range is None:
        return None
    multiplier = {'k': 1_000, 'm': 1_000_000}
    if volume_range.startswith('<'):
        value = float(re.findall(r'\d+', volume_range)[0]) * multiplier[volume_range[-1]]
        return (0, value)
    elif volume_range.startswith('>'):
        value = float(re.findall(r'\d+', volume_range)[0]) * multiplier[volume_range[-1]]
        return (value, float('inf'))
    elif '-' in volume_range:
        lower, upper = re.findall(r'\d+[km]', volume_range)
        lower_value = float(re.findall(r'\d+', lower)[0]) * multiplier[lower[-1]]
        upper_value = float(re.findall(r'\d+', upper)[0]) * multiplier[upper[-1]]
        return (lower_value, upper_value)
    return None

def is_within_range(value, range_tuple):
    """Check if a value is within a given range tuple."""
    if range_tuple is None:
        return True
    return range_tuple[0] <= value <= range_tuple[1]

def get_month_from_day_of_year(day_of_year, year):
    """Get the month from the day of the year."""
    date = datetime.strptime(f"{year}-{day_of_year}", "%Y-%j")
    return date.month

def parse_capture_delay(fee_capture_delay):
    """Parse the capture_delay value from fees.json to handle fuzzy match cases."""
    if fee_capture_delay is None:
        return range(0, 100)

    if isinstance(fee_capture_delay, str):
        if fee_capture_delay.startswith("<"):
            upper_limit = int(fee_capture_delay[1:])
            return range(0, upper_limit)
        elif fee_capture_delay.startswith(">"):
            lower_limit = int(fee_capture_delay[1:]) + 1
            return range(lower_limit, 100)
        elif "-" in fee_capture_delay:
            lower_limit, upper_limit = map(int, fee_capture_delay.split("-"))
            return range(lower_limit, upper_limit + 1)
        else:
            try:
                int(fee_capture_delay)
                return [fee_capture_delay]
            except ValueError:
                return [fee_capture_delay]

    return [str(fee_capture_delay)]

# Define characteristics for Belles_cookbook_store
target_merchant = "Belles_cookbook_store"
target_day_of_year = 10
target_year = 2023

# Extract Belles_cookbook_store's information from merchant_data
merchant_info = next((m for m in merchant_data if m['merchant'] == target_merchant), None)
if not merchant_info:
    final_answer("Not Applicable")
else:
    capture_delay = str(merchant_info["capture_delay"])
    merchant_category_code = merchant_info['merchant_category_code']
    account_type = merchant_info['account_type']

    # Load payments data
    with open('./test_case/dabstep_data/payments.csv', 'r') as csvfile:
        reader = csv.DictReader(csvfile)
        all_transactions = list(reader)

    # Determine the target month
    target_month = get_month_from_day_of_year(target_day_of_year, target_year)

    # Filter all transactions for the target month
    all_month_transactions = [
        row for row in all_transactions
        if int(row['year']) == target_year and
        get_month_from_day_of_year(int(row['day_of_year']), int(row['year'])) == target_month and
        row['merchant'] == target_merchant
    ]

    # Filter transactions for the target merchant and day
    relevant_transactions = [
        row for row in all_transactions
        if row['merchant'] == target_merchant and
        int(row['year']) == target_year and
        int(row['day_of_year']) == target_day_of_year
    ]

    # Calculate monthly fraud level and volume
    total_volume = sum(float(tx['eur_amount']) for tx in all_month_transactions)
    fraud_transactions = [tx for tx in all_month_transactions if tx['has_fraudulent_dispute'] == 'TRUE']
    fraud_volume = sum(float(tx['eur_amount']) for tx in fraud_transactions)
    monthly_fraud_level = (fraud_volume / total_volume) * 100 if total_volume > 0 else 0

    applicable_fees = set()

    for transaction in relevant_transactions:
        transaction_aci = transaction['aci'].strip() 
        transaction_card_scheme = transaction['card_scheme'].strip()
        transaction_is_credit = (
            None if transaction['is_credit'] == '' else
            True if transaction['is_credit'] == 'TRUE' else
            False
        )
        transaction_intracountry = 1.0 if transaction['ip_country'] == transaction['acquirer_country'] else 0.0

        for fee in fees_data:
            fee_card_scheme = fee.get('card_scheme')
            fee_is_credit = fee.get('is_credit')
            fee_intracountry = fee.get('intracountry')
            fee_capture_delay = fee.get('capture_delay')
            fee_aci_list = fee.get('aci', [])
            fee_account_type_list = fee.get('account_type', [])
            fee_merchant_category_code_list = fee.get('merchant_category_code', [])
            fee_monthly_fraud_level_range = parse_percentage_range(fee.get('monthly_fraud_level'))
            fee_monthly_volume_range = parse_volume_range(fee.get('monthly_volume'))
            fee_capture_delay_range = parse_capture_delay(fee_capture_delay)

            if (
                (fee_aci_list == [] or transaction_aci in fee_aci_list) and
                transaction_card_scheme == fee_card_scheme and
                (fee_is_credit is None or fee_is_credit == transaction_is_credit) and
                (fee_intracountry is None or fee_intracountry == transaction_intracountry) and
                (fee_capture_delay_range is None or str(capture_delay) in map(str, fee_capture_delay_range)) and
                (fee_account_type_list == [] or account_type in fee_account_type_list) and
                (fee_merchant_category_code_list == [] or str(merchant_category_code) in fee_merchant_category_code_list) and
                is_within_range(monthly_fraud_level, fee_monthly_fraud_level_range) and
                is_within_range(total_volume, fee_monthly_volume_range)
            ):
                fee_id = str(fee['ID'])
                applicable_fees.add(fee_id)

    if not applicable_fees:
        answer = ""
    else:
        answer = ", ".join(sorted(applicable_fees))
    
    final_answer(answer if answer else "Not Applicable")
```
